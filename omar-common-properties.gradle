import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import org.gradle.api.tasks.Copy

buildscript {
    ext {
        springBootV = "1.5.10.RELEASE"
	springCloudDependencyV = "Dalston.SR5"
        artifactoryContextUrl="https://artifactory.ossim.io/artifactory"
        ossimMavenProxy="${artifactoryContextUrl}/ossim-deps"
        omarMavenProxy="${artifactoryContextUrl}/omar-local"
	benManesV = "0.17.0"
	assetPipelineGradleV = "2.14.8"
	assetPipelineGrailsV = "2.14.8"
	springBootAdminStarterClientV = "1.5.7"
	bootstrapSelectV = "2.0.0-beta1"
	slickCarouselV = "1.8.1"
	angularSlickCarouselV = "3.1.7"
	selectizeV = "0.12.4"
	seiyriaBootstrapSliderV = "9.7.2"
	babelAssetPipelineV = "2.1.1"
	hibernateCoreV = "5.1.9.Final"
	elImplV = "2.2.1-b05"
	seleniumHtmlUnitDriverV = "2.52.0"
	htmlUnitV = "2.29"
	javaSdkDynamodbV = "1.11.279"
	springDataDynamodbV = "5.0.1"
	gradleDockerPluginV = "3.2.4"
	jodaTimeV = "2.9.9"
	webjarsSwaggerUIV = "3.9.3"
	postgressqlV = "42.2.1"
	hibernateSpatialV = "5.3.0.CR1"
	hibernate5V = "6.1.8"
	httpBuilderNgCoreV = "1.0.3"
	quartzV = "2.0.13"
	httpBuilderV = "0.7.2"
	awsJavaSDKV = "1.11.281"
	commonsIoV = "2.6"
	springSecurityCoreV = "3.3.0.M1"
	npmCesiumV = "1.42.1"
        branchToVersionCheck="OCS-2628"
    }
    repositories {

     mavenLocal()

     maven { url "${ossimMavenProxy}" }
     maven { url "${omarMavenProxy}" }
      jcenter()
      maven {
        url "https://plugins.gradle.org/m2/"
      }
    }
    dependencies {
      classpath 'com.bmuschko:gradle-docker-plugin:3.0.12'
      classpath 'com.github.skhatri:gradle-s3-plugin:1.0.4'
      classpath "org.jfrog.buildinfo:build-info-extractor-gradle:latest.release"
      classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.5"
      classpath "com.radiantblue.versionupdater:versionUpdaterPlugin:1.1"
   }
}

apply plugin: com.bmuschko.gradle.docker.DockerRemoteApiPlugin
apply plugin: com.github.skhatri.s3aws.plugin.S3Plugin
apply plugin: org.jfrog.gradle.plugin.artifactory.ArtifactoryPlugin
apply plugin: com.radiantblue.versionupdater.VersionUpdaterPlugin

repositories {
 // maven { url "${ossimMavenProxy}" }
}

def lazyProperty(final String propertyName) {
    // Get property.
    def result
    def propertyValue
    if(project.ext.has(propertyName))
    {
      propertyValue = project.ext."${propertyName}"
    }
    else if(project.hasProperty(propertyName))
    {
      propertyValue = project."${propertyName}"
    }
    if(propertyValue)
    {

      // Check for type of property to see if we can
      // run it as a Closure.
      if (propertyValue instanceof Closure)
      {
          // Invoke Closure to calculate the value.
          result = propertyValue()
      }
      else
      {
          // Return value as-is.
          result = propertyValue
      }

    }
    result
}



def getCurrentGitBranch() {
    def gitBranch = "Unknown branch"
    try {
      println "${project.projectDir}"
        def workingDir = new File("${project.projectDir}")
        def result = 'git rev-parse --abbrev-ref HEAD'.execute(null, workingDir)
        result.waitFor()
        if (result.exitValue() == 0) {
            gitBranch = result.text.trim()
        }
    } catch (e) {
      e.printStackTrace()
    }
    return gitBranch
}
def gitBranch=getCurrentGitBranch()

ext {
  // This property is used exclusively for determining whether or not to do the final git
  //   git commit for a version updated (or at least checked) repository. The updateTheVersion
  //   task may change this property to false to indicate processing on the given projectRoot
  //   should come to a stop.
  doVersionUpdateCommit="true"

  buildVersionTag=gitBranch=="master"?"RELEASE":"SNAPSHOT"
  //  jarArtifactsChanging="${buildVersionTag}" == "SNAPSHOT" ? true:false

  // for now we will set it to true until we get the versioning going.  For our JARS that we rebuild
  // all the time even for Patches made to master we need the changing flag to be true.  This will always
  // force a check for hash.
  //
  jarArtifactsChanging=true
  artifactoryUser="${System.env.ARTIFACTORY_USER}"
  artifactoryPassword="${System.env.ARTIFACTORY_PASSWORD}"

  openShiftUrl = "${System.env.OPENSHIFT_URL}"
  yumTag=(buildVersionTag=="SNAPSHOT"?"dev":"master")
  dockerAppTag="${System.env.DOCKER_TAG}"
  dockerRegistryUrl="${System.env.DOCKER_REGISTRY_URL}"
  registryProjectName="${System.env.REGISTRY_PROJECT_NAME}"
  openShiftUserName="${System.env.OPENSHIFT_USERNAME}"
  openShiftPassword="${System.env.OPENSHIFT_PASSWORD}"
  dockerNamespaceUrl = "${dockerRegistryUrl}/${registryProjectName}/"

  image = "${project.name}:${dockerAppTag}"
  imageTgz = "${project.name}.tgz"

  installOssim = true
}

Boolean fullAssemble = lazyProperty('fullAssemble')
if(fullAssemble == null)
{
  String projName = "${project.name}"
  fullAssemble = true;
  if(projName.contains("-plugin"))
  {
    fullAssemble = false
  }
}
def dockerFile = lazyProperty('dockerFile')
if(!dockerFile)
{
  dockerFile = project.file('build/libs/Dockerfile')
}
else
{
  dockerFile = project.file(dockerFile)
}

Boolean hasJar = lazyProperty('hasJar')
if(hasJar == null)
{
  hasJar = true
}
version "${buildVersion}-${buildVersionTag}"

task checkVersionStatus() {
/*
   withCredentials([[$class: 'usernamePassword',
      credentialsId: 'ossimlabs-minion',
      usernameVariable: 'USERNAME', 
      passwordVariable: 'PASSWORD']]) {
*/

      println "1111111111111111 USERNAME: ${System.env.GIT_USER} PASSWORD: ${System.env.GIT_PASSWORD}"
//}

   // Call the radiantblue plugin that checks if anything was committed since last time
   dependsOn updateTheVersion
   doLast {
      // The external project property 'doVersionUpdateCommit' is defaulted to 'true'
      //   for every project that gets funneled through this omar-common script. However,
      //   we are ony interested in doing version updates for the correct repos for this
      //   rootProject directory. If this script wanders into a different base repo, then
      //   the 'updateTheVersion' task will set the 'doVersionUpdateCommit' to 'false'
      //   for that repo an the call to 'doFinalVersionCommit' will be skipped.
      //println "doVersionUpdateCommit: " + project.ext.get("doVersionUpdateCommit")
      if (doVersionUpdateCommit == "true") {
         doFinalVersionCommit()
      }
   }
}

def doFinalVersionCommit() {
   //withCredentials([usernamePassword(credentialsId: 'ossimlabs-minion',
                    //usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
   //println "USERNAME: ${USERNAME} PASSWORD: ${PASSWORD}"
   //println "<<<<<<<<<<<<<<<<CREDENTIALS: ${GIT_CREDENTIALS}"

   def String projectRoot = project.rootDir
   def String projectDir = project.projectDir
   def String retval

   println "+++++++ doFinalVersionCommit: Attempting commit on repo " + projectRoot


   def String 
   boolean isDone = false

   def sout = new StringBuilder(), serr = new StringBuilder()

   // We need to have a git identity for this commit and subsequent push
   def configProc = "git config user.name ossimlabs-minion".execute()
   configProc.consumeProcessOutput(sout, serr)
   configProc.waitFor()

   configProc = "git config user.email ossimlabs-minion@radiantsolutions.com".execute()
   configProc.consumeProcessOutput(sout, serr)
   configProc.waitFor()

   configProc = "git config --global push.default simple".execute()
   configProc.consumeProcessOutput(sout, serr)
   configProc.waitFor()

   while (!isDone) {
      sout = new StringBuilder()
      serr = new StringBuilder()
      // Build the git commit process and execute it for this repo
      def commitProc = "git --git-dir=${projectRoot}/.git commit -m RELEASE_UPDATE".execute()
      commitProc.consumeProcessOutput(sout, serr)
      commitProc.waitFor()

      // Due to the timing of how these parallel buiild run, we occassionaly run into a lock file for
      //   git. If serr is non-zero, that is the case and we should try to wait for the lock file to
      //   get cleaned up.
      if (serr != null && serr.size() > 0) {
         println "==============Commit FAILED > ${serr}"
         // A simple loop to wait for the git lock file to get cleaned up. Include the failsafe of
         // maximum attempts to wait for the lock
         def filename = "${projectRoot}/.git/index.lock"
         def lockfile = new File(filename)
         def lockTries = 0
         while (lockfile.exists() && ++lockTries < 10) {
            sleep(1000)
         }

         // Prevent an infinite wait
         if (lockTries == 10) {
            println "WARN: lockTries exceeded for ${filename}"
            println "      git commit failed!"

            // Going to eject out of outer loop after 10 attempts to wait/release the lock file
            isDone = true
         }
      }
      else {
         println "==============Commit was successful >  ${sout}"
         isDone = true

         sout = new StringBuilder()
         serr = new StringBuilder()

         def myproj = new File("${project.rootDir}")
         String projname = myproj.getName()

         //String mystr = "git push --set-upstream https://${System.env.GIT_USER}:${System.env.GIT_PASSWORD}@github.com/ossimlabs/${projname}.git ${branchToVersionCheck}"
         String mystr = "git push --set-upstream origin ${branchToVersionCheck}"

         //String pushStr = "git --git-dir=${projectRoot}/.git push --set-upstream origin ${branchToVersionCheck}"
println "PUSHSTR: ${mystr}"

         //def pushProc = "git --git-dir=${projectRoot}/.git push --set-upstream origin ${branchToVersionCheck}".execute()
         //def pushProc = "git --git-dir=${projectRoot}/.git push".execute()
         def pushProc = "${mystr}".execute()
         pushProc.consumeProcessOutput(sout, serr)
         pushProc.waitFor()

         if (serr == null || serr.size() == 0) {
            println "==============Push was successful"
         }
         else {
         println "==============PUSH FAILED > ${serr}"
         }
      }
   }
   //}
}

task logIn () {
  doLast {
    def login = false
    def count = 0
    def numRetries = 3
    def sleepMillis = 1000
    while(!login && count < numRetries){
      try{
        exec {
          commandLine 'oc', 'login', '--insecure-skip-tls-verify', openShiftUrl,
           '-u', openShiftUserName,
           '-p', openShiftPassword
        }
        login = true
      }
      catch(e){

        println 'Openshift login failed!'
        count++
        if(count < numRetries){
          Thread.sleep(sleepMillis)
        }
        else {
          throw(e)
        }
      }
    }

    def loginTokenStream = new ByteArrayOutputStream()
    exec {
      commandLine 'oc', 'whoami', '-t'
      standardOutput loginTokenStream
    }

    def loginToken = new String(loginTokenStream.toByteArray(), 'UTF-8')?.trim()
    println loginToken
    exec {
     commandLine 'docker', 'login', '-p', loginToken, '-u', 'unused', dockerRegistryUrl
    }
  }
}


task downloadBaseImage(type:com.github.skhatri.s3aws.plugin.S3DownloadTask) {
  bucket = "o2-delivery/${gitBranch}/docker"
  key = "${lazyProperty('baseImage')}.tgz"
  saveTo = file("${dockerFile.parentFile}/${lazyProperty('baseImage')}.tgz")
}

task loadBaseDockerImage(dependsOn: downloadBaseImage) {

  doLast {
    exec {
      commandLine 'docker', 'load', '-i', "${dockerFile.parentFile}/${lazyProperty('baseImage')}.tgz"
    }
  }
}

task copyJarToDockerDir(type: Copy){
  from "${buildDir}/libs/${project.name}-${buildVersion}-${buildVersionTag}.jar"
  into "${projectDir}/docker"
}

//task createDockerfile(type: Dockerfile, dependsOn: loadBaseDockerImage){
task createDockerfile(type: Dockerfile){

  def statementOverride = lazyProperty("dockerStatementsOverride");
  def jarName = "${project.name}-${buildVersion}-${buildVersionTag}.jar"
  destFile = dockerFile
  if(statementOverride)
  {
    statementOverride.each{
      instruction it
    }
  }
  else
  {
    instruction "FROM ${lazyProperty('dockerNamespaceUrl')}${lazyProperty('baseImage')}:${lazyProperty('dockerAppTag')}"
    instruction """ENV SPRING_CLOUD_CONFIG_ENABLED=true \\
    SPRING_CLOUD_DISCOVERY_ENABLED=true"""
    instruction "EXPOSE 8080"
    instruction "COPY ${jarName} /home/omar"
    instruction 'WORKDIR /home/omar'
    instruction "CMD java -server -Xms256m -Xmx1024m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+UseGCOverheadLimit -XX:+UnlockExperimentalVMOptions  -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=1 -Djava.security.egd=file:/dev/./urandom -jar ${jarName}"
  }
}

task buildDockerImage(type: DockerBuildImage) {
  dependsOn createDockerfile
  dependsOn logIn
  inputDir = createDockerfile.destFile.parentFile
  tag = "${image}"
}

task tagDockerImage(type: DockerTagImage, dependsOn: buildDockerImage){
  imageId "${image}"
  tag "${dockerAppTag}"
  repository  "${dockerNamespaceUrl}${project.name}"
}


task pushDockerImage(/*type: DockerPushImage*/){
  dependsOn tagDockerImage
  doLast {
    exec {
      commandLine 'docker', 'push', "${dockerNamespaceUrl}${image}"
    }
  }
/*
  dependsOn tagDockerImage

  imageName "${dockerNamespaceUrl}${image}"
*/
}

task saveDockerImage(dependsOn: pushDockerImage) {
  doLast {
    exec {
      commandLine 'docker', 'save', image, '-o', "${dockerFile.parentFile}/${project.name}.tgz"
    }
  }
}

// Uses the S3 plugin to push the .tgz file to the ossimlabs
task dockerImageToS3(type: com.github.skhatri.s3aws.plugin.S3UploadTask, dependsOn: saveDockerImage) {
  bucket = "o2-delivery/${gitBranch}/docker"
  key = "${imageTgz}"
  file = ("${dockerFile.parentFile}/${imageTgz}").toString()
}

task dockerFileToS3(type: com.github.skhatri.s3aws.plugin.S3UploadTask, dependsOn: createDockerfile) {
  bucket = "o2-delivery/${gitBranch}/docker"
  key = "${project.name}-Dockerfile"
  file = createDockerfile.destFile.toString()
}

task jarFileToS3(type: com.github.skhatri.s3aws.plugin.S3UploadTask) {
  def jarName = "${project.name}-${buildVersion}-${buildVersionTag}.jar"
  bucket = "o2-delivery/${gitBranch}/jars"
  key = "${jarName}"
  file = "${lazyProperty('projectDir')}/build/libs/${jarName}"
}

task doAll() {
  dependsOn checkVersionStatus
  //dependsOn dockerImageToS3
  //dependsOn dockerFileToS3

/*
  doLast{
    exec {
      // Removes the image that is pushed to the remote repository
      // from the local Docker registry
      commandLine 'docker', 'rmi', "-f", "${dockerNamespaceUrl}${image}"
    }
    exec {
      // Removes the default image created during the build process from
      // from the local Docker registry
      commandLine 'docker', 'rmi', "-f", image
    }
  }
*/
}

artifactory {
  contextUrl = "${artifactoryContextUrl}"   //The base Artifactory URL if not overridden by the publisher/resolver
  publish {
    repository {
      repoKey = "omar-local"
      username = "${artifactoryUser}"
      password = "${artifactoryPassword}"
      maven = true
    }
    defaults{
      publications("mavenJava")
    }
  }
  resolve {
    repository {
      repoKey = "omar-local"
      username = "${artifactoryUser}"
      password = "${artifactoryPassword}"
      maven = true
    }
  }
}
if(fullAssemble)
{
  artifactoryPublish.dependsOn.add("assemble")
  jarFileToS3.dependsOn.add("assemble")
  copyJarToDockerDir.dependsOn("assemble")
}

if( hasJar )
{
  doAll.dependsOn.add("jarFileToS3")
  if(lazyProperty('dockerFile'))
  {
     createDockerfile.dependsOn.add("copyJarToDockerDir")
  }
}
